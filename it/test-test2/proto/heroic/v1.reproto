use heroic.common as c;

type Sampling {
    unit?: TimeUnit;
    size: unsigned;
    extent?: unsigned;
}

enum SI {
  NANO = 3;
  MICRO = 2;
  MILLI = 10;

  serialized_as_name true;
}

enum TimeUnit {
  /// Seconds, what do you think?
  SECONDS("seconds", 1000);
  MINUTES("minutes", 60000);

  serialized_as number;

  name: string;
  number: double;

  java {{
    public double toMilliseconds() {
      return this.number;
    }
  }}
}

tuple Point {
  match {
    42 => Point(timestamp: 42, value: 41.2);
    n: unsigned => Point(timestamp: n, value: 42.0);
  }

  timestamp: unsigned/64 as "TS";
  value: double;
}

tuple Event {
  timestamp: unsigned/64;
  payload?: any;
}

interface Samples {
  match {
    name: string => Samples.Points(name: name, data: []);
  }

  name: string;

  Points {
    name "points";

    data: [Point];
  }

  Events {
    name "events";

    data: [Event];
  }
}

type Query {
  match {
    query: string => Query(query: query);
  }

  query?: string;
  aggregation?: Aggregation;
  date?: c::Date;
  parameters?: {string: string};
}

interface Duration {
  Absolute {
    name "absolute";

    start: unsigned/64;
    end: unsigned/64;
  }
}

interface Aggregation {
  match {
    chain: [Aggregation] => Aggregation.Chain(chain: chain);
  }

  Sum {
    name "sum";

    sampling?: Sampling;
    size?: Duration;
    extent?: Duration;
  }

  Average {
    name "average";

    sampling?: Sampling;
    size?: Duration;
    extent?: Duration;
  }

  Chain {
    name "chain";

    chain: [Aggregation];
  }
}

enum ComplexEnum {
  FIRST(Sampling(size: 42), SI.NANO, Samples.Points(name: "points", data: []));
  SECOND(Sampling(size: 9), SI.MILLI, Samples.Points(name: "b", data: []));

  si: Sampling;
  other: SI;
  samples: Samples;
}

enum Complex21 {
  FIRST(Point(timestamp: 123, value: 42.1));
  SECOND(Point(timestamp: 123, value: 1234.12));

  point: Point;
}
