// vim: ft=rust
use super::errors::Error;
use super::token::*;
use super::ast::*;
use reproto_core::*;
use super::utils::*;

grammar<'input>;

pub File: File<'input> = {
    <package_decl:Loc<PackageDecl>> <options:Loc<OptionDecl>*> <uses:Loc<Use>*> <decls:Loc<Decl>*> => File {
        package_decl: package_decl,
        options: options,
        uses: uses,
        decls: decls,
    },
};

Use: UseDecl = {
    "use" <package:Loc<Package>> <version_req:Loc<"@version">?> <alias:("as" IdentifierValue)?> ";" => UseDecl {
        package: package,
        version_req: version_req,
        alias: alias.map(|t| t.1),
    },
};

PackageDecl: PackageDecl = "package" <package:Package> <version:Loc<"@version">?> ";" => PackageDecl {
    package: package,
    version: version,
};
Package: RpPackage = <parts:OneOrMore<".", IdentifierValue>> => RpPackage::new(parts);

Decl: Decl<'input> = {
    <en:Enum> => Decl::Enum(en),
    <interface:Interface> => Decl::Interface(interface),
    <ty:Type> => Decl::Type(ty),
    <tuple:Tuple> => Decl::Tuple(tuple),
    <service:Service> => Decl::Service(service),
};

Enum: EnumBody<'input> =
    "enum" <name:TypeIdentifier> "{"
      <variants:Loc<EnumVariant>*>
      <members:Loc<Member>*>
    "}" =>
{
    EnumBody {
        name: name.value,
        comment: name.comment,
        variants: variants,
        members: members,
    }
};

Interface: InterfaceBody<'input> =
    "interface" <name:TypeIdentifier> "{"
      <members:Loc<Member>*>
      <sub_types:Loc<SubType>*>
    "}" =>
{
    InterfaceBody {
        name: name.value,
        comment: name.comment,
        members: members,
        sub_types: sub_types,
    }
};

Type: TypeBody<'input> =
    "type" <name:TypeIdentifier> "{"
      <members:Loc<Member>*>
    "}" =>
{
    TypeBody {
        name: name.value,
        comment: name.comment,
        members: members,
    }
};

Tuple: TupleBody<'input> =
    "tuple" <name:TypeIdentifier> "{"
      <members:Loc<Member>*>
    "}" =>
{
    TupleBody {
        name: name.value,
        comment: name.comment,
        members: members,
    }
};

Service: ServiceBody<'input> =
    "service" <name:TypeIdentifier> "{"
        <children:ServiceNested*>
    "}" =>
{
    ServiceBody {
        name: name.value,
        comment: name.comment,
        children: children,
    }
};

ServiceNested: ServiceNested<'input> = {
    <endpoint:"endpoint"> <url:Loc<string>> "{" <options:Loc<OptionDecl>*> <children:ServiceNested*> "}" => {
        ServiceNested::Endpoint {
            url: url,
            comment: endpoint,
            options: options,
            children: children,
        }
    },
    <returns:"returns"> <ty:Loc<TypeSpec>> "{" <options:Loc<OptionDecl>*> "}" => {
        ServiceNested::Returns {
            comment: returns,
            ty: ty,
            options: options,
        }
    },
    <star:"*"> "{" <options:Loc<OptionDecl>*> <children:ServiceNested*> "}" => {
        ServiceNested::Star {
            comment: star,
            options: options,
            children: children,
        }
    },
};

EnumVariant: EnumVariant<'input> =
    <name:Loc<TypeIdentifier>>
    <arguments:("(" OneOrMore<",", Loc<Value>> ")")?>
    <ordinal:("=" Loc<Value>)?>
    ";" =>
{
    let comment = name.comment.clone();

    EnumVariant {
        name: name.map_into(|n| n.value),
        comment: comment,
        arguments: arguments.map(|a| a.1).unwrap_or_else(|| vec![]),
        ordinal: ordinal.map(|o| o.1),
    }
};

pub Member: Member<'input> = {
    <name:Identifier> <modifier:"?"?> ":" <ty:TypeSpec> <alias:("as" Loc<Value>)?> ";" => {
         let field = Field {
             modifier: modifier.map(|_| RpModifier::Optional).unwrap_or(RpModifier::Required),
             name: name.value,
             comment: name.comment,
             ty: ty,
             field_as: alias.map(|a| a.1),
         };

         Member::Field(field)
    },

    "match" "{" <members:Loc<MatchMember>*> "}" => {
         let m = MatchDecl {
             members: members
         };

         Member::Match(m)
    },

    <option:Loc<OptionDecl>> => {
         Member::Option(option)
    },

    <context:IdentifierValue> "{{" <content:code> "}}" => {
        let content = strip_code_block(content);
        Member::Code(context, content)
    },
};

OptionDecl: OptionDecl = <name:IdentifierValue> <values:OneOrMore<",", Loc<Value>>> ";" => OptionDecl {
    name: name,
    values: values,
};

MatchMember: MatchMember = {
    <condition:Loc<MatchCondition>> "=>" <value:Loc<Value>> ";" => MatchMember {
        condition: condition,
        value: value,
    },
};

MatchCondition: MatchCondition = {
    <variable:Loc<MatchVariable>> => MatchCondition::Type(variable),
    <value:Loc<Value>> => MatchCondition::Value(value),
};

MatchVariable: MatchVariable = <name:IdentifierValue> ":" <ty:TypeSpec> => MatchVariable {
    name: name.to_owned(),
    ty: ty,
};

SubType: SubType<'input> = {
    <name:TypeIdentifier> "{" <members:Loc<Member>*> "}" => {
         SubType {
             name: name.value,
             comment: name.comment,
             members: members,
         }
    },
};

pub Value: Value = {
    "[" <values:ZeroOrMore<",", Loc<Value>>> "]" => Value::Array(values),
    <instance:Loc<Instance>> => Value::Instance(instance),
    <constant:Loc<Name>> => Value::Constant(constant),
    <string:string> => Value::String(string),
    <number:Number> => Value::Number(number),
    <true> => Value::Boolean(true),
    <false> => Value::Boolean(false),
    <identifier:IdentifierValue> => Value::Identifier(identifier),
};

Instance: Instance = {
    <name:Name> "(" <arguments:Loc<ZeroOrMore<",", Loc<FieldInit>>>> ")" => Instance {
        name: name,
        arguments: arguments,
    },
};

FieldInit: FieldInit = {
    <name:Loc<IdentifierValue>> ":" <value:Loc<Value>> => FieldInit {
        name: name,
        value: value,
    },
};

pub TypeSpec: RpType = {
    "any" => RpType::Any,
    "float" => RpType::Float,
    "double" => RpType::Double,
    "signed" <size:TypeBits?> => RpType::Signed {
        size: size
    },
    "unsigned" <size:TypeBits?> => RpType::Unsigned {
        size: size
    },
    "boolean" => RpType::Boolean,
    "string" => RpType::String,
    "bytes" => RpType::Bytes,
    <name:Name> => RpType::Name{
        name: name
    },
    "[" <inner:TypeSpec> "]" => RpType::Array {
        inner: Box::new(inner)
    },
    "{" <key:TypeSpec> ":" <value:TypeSpec> "}" => RpType::Map{
        key: Box::new(key),
        value: Box::new(value)
    },
};

Name: RpName = {
    <prefix:(IdentifierValue "::")?> <parts:OneOrMore<".", TypeIdentifierValue>> => RpName {
        prefix: prefix.map(|p| p.0),
        parts: parts,
    }
};

TypeBits: usize = "/" <number:Number> => number.to_usize().unwrap_or(0usize);

/// Zero or more matching, separated by a token.
ZeroOrMore<Sep, T>: Vec<T> = {
    <value:OneOrMore<Sep, T>?> => {
        value.unwrap_or_else(|| vec![])
    }
};

/// One or more matching, separated by a token.
OneOrMore<Sep, T>: Vec<T> = {
     <values:(<T> Sep)*> <last:T> => {
        let mut values = values;
        values.push(last);
        values
    }
};

IdentifierValue: String = <identifier:Identifier> => identifier.value.to_owned();
TypeIdentifierValue: String = <identifier:TypeIdentifier> => identifier.value.to_owned();

Loc<Inner>: AstLoc<Inner> = <s:@L> <inner:Inner> <e:@R> => AstLoc::new(inner, (s, e));

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'input> {
        TypeIdentifier => Token::TypeIdentifier(<Commented<'input, &'input str>>),
        Identifier => Token::Identifier(<Commented<'input, &'input str>>),
        Number => Token::Number(<RpNumber>),
        "@version" => Token::Version(<String>),
        "match" => Token::MatchKeyword,
        "use" => Token::UseKeyword,
        "as" => Token::AsKeyword,
        "enum" => Token::EnumKeyword,
        "type" => Token::TypeKeyword,
        "interface" => Token::InterfaceKeyword,
        "tuple" => Token::TupleKeyword,
        "service" => Token::ServiceKeyword,
        "package" => Token::PackageKeyword,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftCurly,
        "}" => Token::RightCurly,
        "{{" => Token::CodeOpen,
        "}}" => Token::CodeClose,
        code => Token::CodeContent(<&'input str>),
        string => Token::String(<String>),
        "[" => Token::LeftBracket,
        "]" => Token::RightBracket,
        ";" => Token::SemiColon,
        ":" => Token::Colon,
        "?" => Token::Optional,
        "/" => Token::Slash,
        "=" => Token::Equals,
        "=>" => Token::HashRocket,
        "," => Token::Comma,
        "." => Token::Dot,
        "::" => Token::Scope,
        "any" => Token::AnyKeyword,
        "on" => Token::OnKeyword,
        "float" => Token::FloatKeyword,
        "double" => Token::DoubleKeyword,
        "signed" => Token::SignedKeyword,
        "unsigned" => Token::UnsignedKeyword,
        "boolean" => Token::BooleanKeyword,
        "string" => Token::StringKeyword,
        "bytes" => Token::BytesKeyword,
        true => Token::TrueKeyword,
        false => Token::FalseKeyword,
        "endpoint" => Token::EndpointKeyword(<Vec<&'input str>>),
        "returns" => Token::ReturnsKeyword(<Vec<&'input str>>),
        "*" => Token::Star(<Vec<&'input str>>),
    }
}
