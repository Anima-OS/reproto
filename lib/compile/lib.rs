extern crate reproto_ast as ast;
extern crate reproto_backend as backend;
extern crate reproto_core as core;
extern crate reproto_manifest as manifest;

use core::{ContextItem, Object, Resolver, RpPackage, RpVersionedPackage};
use std::cell::RefCell;
use std::fmt;
use std::rc::Rc;
use std::str;

/// Input to the compiler.
pub enum Input<'input> {
    /// Already derive file.
    File(ast::File<'input>, Option<RpVersionedPackage>),
    /// Object that should be parsed.
    Object(Box<Object>, Option<RpVersionedPackage>),
}

/// A simple compilation stage.
pub struct SimpleCompile<'input> {
    pub input: Input<'input>,
    pub package_prefix: Option<RpPackage>,
    pub resolver: Option<Box<Resolver>>,
    pub errors: Option<Rc<RefCell<Vec<ContextItem>>>>,
}

impl<'input> SimpleCompile<'input> {
    /// Build a new compilation stage.
    pub fn new(input: Input<'input>) -> SimpleCompile {
        Self {
            input: input,
            package_prefix: None,
            resolver: None,
            errors: None,
        }
    }

    /// Set package prefix.
    pub fn package_prefix(self, package: RpPackage) -> Self {
        Self {
            package_prefix: Some(package),
            ..self
        }
    }

    /// Set resolver.
    pub fn resolver(self, resolver: Box<Resolver>) -> Self {
        Self {
            resolver: Some(resolver),
            ..self
        }
    }

    /// Set a reference to collect errors.
    pub fn with_errors(self, errors: Rc<RefCell<Vec<ContextItem>>>) -> Self {
        Self {
            errors: Some(errors),
            ..self
        }
    }
}

/// Perform a simplified compilation that outputs the result into the provided Write
/// implementation.
pub fn simple_compile<L: manifest::Lang, C>(
    out: &mut fmt::Write,
    config: SimpleCompile,
    modules: Vec<L::Module>,
    compile: C,
) -> core::errors::Result<()>
where
    C: Fn(Rc<core::Context>, backend::Environment, manifest::Manifest<L>) -> core::errors::Result<()>,
{
    let SimpleCompile {
        input,
        package_prefix,
        resolver,
        errors,
    } = config;

    let resolver = resolver.unwrap_or_else(|| Box::new(core::EmptyResolver));

    let capturing = core::CapturingFilesystem::new();

    let ctx = core::Context::new(capturing.filesystem());

    // Set errors reference, if configured.
    let ctx = if let Some(errors) = errors {
        ctx.with_errors(errors)
    } else {
        ctx
    };

    let ctx = Rc::new(ctx);

    let mut env = backend::Environment::new(ctx.clone(), package_prefix.clone(), resolver);

    match input {
        Input::File(file, package) => {
            env.import_file(file, package)?;
        }
        Input::Object(object, package) => {
            env.import_object(object.as_ref(), package)?;
        }
    }

    let preamble = manifest::ManifestPreamble::new(Some(manifest::Language::Java), None);
    let mut manifest = manifest::read_manifest::<L>(preamble)?;
    manifest.modules = modules;
    manifest.package_prefix = package_prefix;

    compile(ctx, env, manifest)?;

    let borrowed = capturing.files().try_borrow()?;

    let comment = format!(
        " {} file(s) generated by https://github.com/reproto",
        borrowed.len()
    );

    if let Some(comment) = L::comment(comment.as_str()) {
        writeln!(out, "{}", comment.as_str())?;
        writeln!(out, "")?;
    }

    let mut it = borrowed.iter().peekable();

    while let Some((path, content)) = it.next() {
        if let Some(comment) = L::comment(format!(" File: {}", path.display()).as_str()) {
            writeln!(out, "{}", comment)?;
            writeln!(out, "")?;
        }

        out.write_str(str::from_utf8(content)?)?;

        if it.peek().is_some() {
            writeln!(out, "")?;
        }
    }

    Ok(())
}
