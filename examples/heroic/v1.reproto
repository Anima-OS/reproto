package heroic.v1;

version "1.0.0";

use heroic.common@[=1] as c;

type Sampling {
    // Unit of sampling
    unit?: TimeUnit;
    // Size of the sampling.
    size: unsigned;
    // Extend ot the sampling.
    extent?: unsigned;
}

enum SI {
  NANO = 3;
  MICRO = 2;
  MILLI = 10;

  serialized_as_name true;
}

enum TimeUnit {
  // Seconds
  SECONDS("seconds", 1000);
  // Minutes
  MINUTES("minutes", 60000);

  serialized_as number;

  // The name of the time unit
  name: string;
  // The number of the time unit
  number: double;

  java {{
    public double toMilliseconds() {
      return this.number;
    }
  }}
}

// # Models a single sampled point
//
// Events are ways to store arbitrary pieces of information over time.
//
// # Example
//
// ```json
// [12, 42.0]
// ```
tuple Point {
  match {
    n: unsigned => Point(timestamp: n, value: 0.0);
  }

  timestamp: unsigned/64;
  value: double;
}

// # Models a single sampled point
//
// Points store numeric values over time.
//
// # Examples
//
// ```json
// [12, "hello"]
// ```
//
// ```json
// [12, {"foo": "bar"}]
// ```
tuple Event {
  timestamp: unsigned/64;
  payload?: any;
}

interface Samples {
  match {
    name: string => Samples.Points(name: name, data: []);
  }

  // Name of the current set of samples
  //
  // ```
  // This is an example code-block.
  // ```
  name: string;

  Points {
    name "points";

    // List of points
    data: [Point];
  }

  Events {
    name "events";

    // List of events
    data: [Event];
  }
}

type Query {
  query?: string;
  aggregation?: Aggregation;
  date?: c::Date;
  parameters?: {string: string};
}

interface Duration {
  Absolute {
    name "absolute";

    start: unsigned/64;
    end: unsigned/64;
  }
}

interface Aggregation {
  match {
    chain: [Aggregation] => Aggregation.Chain(chain: chain);
  }

  Sum {
    name "sum";

    sampling?: Sampling;
    size?: Duration;
    extent?: Duration;
  }

  Average {
    name "average";

    sampling?: Sampling;
    size?: Duration;
    extent?: Duration;
  }

  Chain {
    name "chain";

    chain: [Aggregation];
  }
}
